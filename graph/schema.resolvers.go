package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"

	"github.com/aakarsh-kamboj/echo-practise/graph/model"
	"github.com/google/uuid"
)

// CreateFramework is the resolver for the createFramework field.
func (r *mutationResolver) CreateFramework(ctx context.Context, input *model.CreateFramework) (*model.Framework, error) {
	framework, err := r.FrameworkService.CreateFramework(ctx, input.Name, input.Description, input.Version, input.Locked, input.Editable, input.Category)
	if err != nil {
		return nil, err
	}
	return &model.Framework{
		ID:          framework.ID.String(),
		Name:        &framework.Name,
		Description: &framework.Description.String,
		Version:     &framework.Version.String,
		Locked:      &framework.Locked,
		Editable:    &framework.Editable,
		Category:    framework.Category,
		CreatedAt:   framework.CreatedAt,
		UpdatedAt:   framework.UpdatedAt,
	}, nil
}

// UpdateFramework is the resolver for the updateFramework field.
func (r *mutationResolver) UpdateFramework(ctx context.Context, input *model.UpdateFramework) (*model.Framework, error) {
	framework, err := r.FrameworkService.UpdateFramework(ctx, uuid.MustParse(input.ID), *input.Name, *input.Description, *input.Version, *input.Locked, *input.Editable, input.Category)
	if err != nil {
		return nil, err
	}
	return &model.Framework{
		ID:          framework.ID.String(),
		Name:        &framework.Name,
		Description: &framework.Description.String,
		Version:     &framework.Version.String,
		Locked:      &framework.Locked,
		Editable:    &framework.Editable,
		Category:    framework.Category,
		CreatedAt:   framework.CreatedAt,
		UpdatedAt:   framework.UpdatedAt,
	}, nil
}

// DeleteFramework is the resolver for the deleteFramework field.
func (r *mutationResolver) DeleteFramework(ctx context.Context, input *model.DeleteFramework) (*model.Message, error) {
	msg, err := r.FrameworkService.DeleteFramework(ctx, uuid.MustParse(input.ID))
	if err != nil {
		return &model.Message{Msg: &msg}, err
	}
	return &model.Message{Msg: &msg}, nil
}

// Framework is the resolver for the framework field.
func (r *queryResolver) Framework(ctx context.Context, id string) (*model.Framework, error) {
	framework, err := r.FrameworkService.GetFrameworkByID(ctx, uuid.MustParse(id))
	if err != nil {
		return nil, err
	}
	return &model.Framework{
		ID:          framework.ID.String(),
		Name:        &framework.Name,
		Description: &framework.Description.String,
		Version:     &framework.Version.String,
		Locked:      &framework.Locked,
		Editable:    &framework.Editable,
		Category:    framework.Category,
	}, nil
}

// Frameworks is the resolver for the frameworks field.
func (r *queryResolver) Frameworks(ctx context.Context) ([]*model.Framework, error) {
	frameworks, err := r.FrameworkService.ListFrameworks(ctx)
	if err != nil {
		return nil, err
	}
	var result []*model.Framework
	for _, f := range frameworks {
		result = append(result, &model.Framework{
			ID:          f.ID.String(),
			Name:        &f.Name,
			Description: &f.Description.String,
			Version:     &f.Version.String,
			Locked:      &f.Locked,
			Editable:    &f.Editable,
			Category:    f.Category,
		})
	}
	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
